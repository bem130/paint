<!DOCTYPE html>
<html>
    <head>
        <title>Neknaj Paint</title>
        <meta charset="utf*8">
        <meta property="og:title" content="Neknaj Paint">
        <meta property="og:description" content="Paint software that runs on a web browser">
        <meta property="description" content="Paint software that runs on a web browser">
    </head>
    <body>
        <div class="resizer_Hcontainer" id="mainarea" data-proportion="15:1">
            <div class="resizer_content">
                <div class="resizer_Vcontainer" data-proportion="13:1">
                    <div class="resizer_content" id="imgOutArea"><canvas id="base"></canvas><canvas id="canvas"></canvas></div>
                    <div class="resizer_splitter"></div>
                    <div class="resizer_content">
                        <input type="color" id="colorpicker">
                        <input type="range" id="linewidth" min="-15" max="30" value="0">
                    </div>
                </div>
            </div>
            <div class="resizer_splitter"></div>
            <div class="resizer_content">
                <div>
                    <button data-stat="off" class="toggle" id="Eraser">Eraser</button>
                </div>
                <div class="singleselectbtn" id="PenType">
                    <button data-value="ballpoint1">BallPoint</button>
                    <button data-value="brush1">Brush</button>
                </div>
            </div>
        </div>
    </body>
</html>
<script src="https://cdn.jsdelivr.net/npm/noisejs@2.1.0/index.min.js"></script>
<script>
function resizer_Vcontainer_addEL (container,framesMin,callback=()=>{}) {
    container.querySelector(":scope > .resizer_splitter").addEventListener("pointerdown",(e)=>{
        let resizer = container.querySelector(":scope > .resizer_splitter").getBoundingClientRect();
        let resizerW = resizer.bottom - resizer.top;
        let resize = (e)=>{
            let containerRect = container.getBoundingClientRect();
            let y = ((n,min,max)=>{if (n<min) {n=min}else if (n>max) {n=max};return n;})(e.y-containerRect.y,framesMin,containerRect.height-resizerW-framesMin);
            container.querySelectorAll(":scope > .resizer_content")[0].style.flexBasis = `${y}%`;
            container.querySelectorAll(":scope > .resizer_content")[1].style.flexBasis = `${containerRect.height-resizerW-y}%`;
            callback();
        }
        document.addEventListener("pointermove",resize,false);
        document.addEventListener("pointerup",()=>{document.removeEventListener("pointermove",resize,false);},false);
        e.target.setPointerCapture(e.pointerId);
    });
    let p = container.dataset["proportion"].split(":").map((x)=>{return Number(x);});
    container.querySelectorAll(":scope > .resizer_content")[0].style.flexBasis = `${(p[0]*100/(p[0]+p[1]))}%`;
    container.querySelectorAll(":scope > .resizer_content")[1].style.flexBasis = `${(p[1]*100/(p[0]+p[1]))}%`;
}
function resizer_Hcontainer_addEL (container,framesMin,callback=()=>{}) {
    container.querySelector(":scope > .resizer_splitter").addEventListener("pointerdown",(e)=>{
        let resizer = container.querySelector(":scope > .resizer_splitter").getBoundingClientRect();
        let resizerW = resizer.right - resizer.left;
        let resize = (e)=>{
            let containerRect = container.getBoundingClientRect();
            let x = ((n,min,max)=>{if (n<min) {n=min}else if (n>max) {n=max};return n;})(e.x-containerRect.x,framesMin,containerRect.width-resizerW-framesMin);
            container.querySelectorAll(":scope > .resizer_content")[0].style.flexBasis = `${x}%`;
            container.querySelectorAll(":scope > .resizer_content")[1].style.flexBasis = `${containerRect.width-resizerW-x}%`;
            callback();
        }
        document.addEventListener("pointermove",resize,false);
        document.addEventListener("pointerup",()=>{document.removeEventListener("pointermove",resize,false);},false);
        e.target.setPointerCapture(e.pointerId);
    });
    let p = container.dataset["proportion"].split(":").map((x)=>{return Number(x);});
    container.querySelectorAll(":scope > .resizer_content")[0].style.flexBasis = `${(p[0]*100/(p[0]+p[1]))}%`;
    container.querySelectorAll(":scope > .resizer_content")[1].style.flexBasis = `${(p[1]*100/(p[0]+p[1]))}%`;
}
document.querySelectorAll(".resizer_Vcontainer").forEach((x)=>{resizer_Vcontainer_addEL(x,50,resize);})
document.querySelectorAll(".resizer_Hcontainer").forEach((x)=>{resizer_Hcontainer_addEL(x,50,resize);})
function resize() {
    {
        const dw = imageConfig.width;
        const dh = imageConfig.height;
        let rw = 0;let rh = 0;
        parent = imgOutArea.getBoundingClientRect();
        let ww = parent.width;
        let wh = parent.height;
        let csc = 1
        hcsc = ww/dw; wcsc = wh/dh;
        if (hcsc>wcsc) {
            csc = wcsc; rw = (ww - dw*csc)/2;
        }
        else {
            csc = hcsc; rh = (wh - dh*csc)/2;
        }
        cnv.style.marginTop = (rh).toString()+"px";
        cnv.style.marginBottom = (rh).toString()+"px";
        cnv.style.marginLeft = (rw).toString()+"px";
        cnv.style.marginRight = (rw).toString()+"px";
        cnv.style.transform = "scale("+csc.toString()+","+csc.toString()+")";
        basecnv.style.marginTop = (rh).toString()+"px";
        basecnv.style.marginBottom = (rh).toString()+"px";
        basecnv.style.marginLeft = (rw).toString()+"px";
        basecnv.style.marginRight = (rw).toString()+"px";
        basecnv.style.transform = "scale("+csc.toString()+","+csc.toString()+")";
    }
};
window.onresize = resize;
window.onload = ()=>{
    cnv.height = 1080;
    cnv.width = 1920;
    basecnv.height = 1080;
    basecnv.width = 1920;
    resize();
    makebase();
};
</script>
<script>
</script>
<script>
var imageConfig = {
    width: 1920,
    height: 1080
}
var basecnv = document.getElementById("base");

var cnv = document.getElementById("canvas");
let ctx = cnv.getContext("2d");
let imgOutArea = document.getElementById("imgOutArea");
// resize window

cnv.addEventListener("contextmenu", (e)=>{e.preventDefault();}, false);

cnv.addEventListener("pointermove", draw, false);

cnv.addEventListener("pointerup", endpath, false);
cnv.addEventListener("pointercancle", endpath, false);
cnv.addEventListener("pointerout", endpath, false);
cnv.addEventListener("pointerleave", endpath, false);

document.addEventListener("keydown",(e)=>{
    console.log("keydown",e.keyCode)
    if (e.keyCode == 90 && e.ctrlKey) {
        cnv_history_trash.push(cnv_history.pop());
        ctx.putImageData(cnv_history[cnv_history.length-1],0,0);
    }
    if (e.keyCode == 89 && e.ctrlKey) {
        if (cnv_history_trash.length>0) {
            cnv_history.push(cnv_history_trash.pop());
            ctx.putImageData(cnv_history[cnv_history.length-1],0,0);
        }
    }
},false);

function logEvents(e) {
    console.log(e);
    return;
}

var stroke = [];
var cnv_history = [];
var cnv_history_trash = [];
let image = ctx.getImageData(0,0,1920,1080);
cnv_history.push(image);

function draw(e) {
   // console.log(e.getCoalescedEvents())
    var rect = cnv.getBoundingClientRect();
    let ns = {x:(e.clientX-rect.left)/(rect.right-rect.left)*cnv.width,y:(e.clientY-rect.top)/(rect.bottom-rect.top)*cnv.height,time:performance.now()}
    let bs = stroke[stroke.length-1]??ns;
    let speed = Math.sqrt((bs.x-ns.x)**2+(bs.y-ns.y)**2)/(ns.time-bs.time);
    let drawfunc = (e)=>{
       // console.log(e)
        let pointer = {
            x: (e.clientX-rect.left)/(rect.right-rect.left)*cnv.width,
            y: (e.clientY-rect.top)/(rect.bottom-rect.top)*cnv.height,
            time: performance.now(),
            tiltX: e.pointerType=="pen"?e.tiltX:0,
            tiltY: 0,
            twist: e.pointerType=="pen"?e.tiltY:45,
            pressure: e.pointerType=="pen"?e.pressure:0.5,
            pointerType: e.pointerType,
            speed: speed,
        }
        console.log(pointer)
        switch (e.buttons) {
            case 1:
                drawpath(pointer);
                //logEvents(pointer);
            break;
        }
    }
    if (e.getCoalescedEvents) {
        for (e of e.getCoalescedEvents()) {
            drawfunc(e);
        }
    }
    else {
        drawfunc(e);
    }
}

function drawpath(e) {
    {
        stroke.push(e);
        // ctx.beginPath();
        // ctx.arc(e.x,e.y,10,0,Math.PI*2)
        // ctx.stroke();
       // console.log(e)
    }

    let linewidth = 3*1.1**Number(document.querySelector("#linewidth").value);
    console.log(linewidth);
    let color = document.querySelector("#colorpicker").value.slice(1).match(/.{2}/g).map((x)=>{return parseInt(x,16)});
    if (stroke.length>3) {
        i = stroke.length-1;
        let p0 = stroke[i-2];
        let p1 = stroke[i-1];
        let p2 = stroke[i];
        let m1 = midpoint(p0,p1);
        let m2 = midpoint(p1,p2);
        drawQuadraticCurve(m1,p1,m2,p0,p1,linewidth,color);
    }
}
function endpath(e) {
    if (stroke.length>2) {
        let image = ctx.getImageData(0,0,1920,1080);
        cnv_history.push(image);
        cnv_history_trash = [];
        console.log(cnv_history);
    }
    stroke = [];
}

function midpoint(p1,p2) {
    return {x:(p1.x+p2.x)/2,y:(p1.y+p2.y)/2}
}
function lerp(a,b,t) {
    return a + t*(b-a)
}

function drawQuadraticCurve(p0,p1,p2,pointer1,pointer2,linewidth,color) {
    let penType = (()=>{
        if (document.querySelector("#Eraser").dataset.stat=="on") {
            return "eraser"
        }
        return document.querySelector("#PenType").dataset.value;
    })();
    let span = 0.005*Math.log(linewidth+3);
    for (let t=0;t<=1;t+=span) {
        x = (p0.x-2*p1.x+p2.x)*t*t+(-2*p0.x+2*p1.x)*t+p0.x;
        y = (p0.y-2*p1.y+p2.y)*t*t+(-2*p0.y+2*p1.y)*t+p0.y;
        switch (penType) {
            case "eraser":
                {
                    ctx.globalCompositeOperation = "destination-out";
                    ctx.fillStyle = `rgb(0,0,0,1)`;
                    ctx.beginPath();
                    ctx.arc(x,y,linewidth,0,Math.PI*2)
                    ctx.fill();
                }
                break;
            case "ballpoint1":
                {
                    ctx.globalCompositeOperation = "source-over";
                    ctx.fillStyle = `rgb(${color.join(",")})`;
                    width1 = linewidth*Math.min(lerp(pointer1.pressure,pointer2.pressure,t)*3,1);
                    width2 = width1;
                    ctx.beginPath();
                    ctx.ellipse(x,y,width2,width1,lerp(pointer1.twist,pointer2.twist,t)*Math.PI/180,0,Math.PI*2)
                    ctx.fill();
                }
                break;
            case "brush1":
                {
                    ctx.globalCompositeOperation = "";
                    ctx.fillStyle = `rgb(${color.join(",")})`;
                    width1 = linewidth*Math.min(lerp(pointer1.pressure,pointer2.pressure,t)*3,1);
                    let projection_len = Math.sqrt(Math.cos((lerp(pointer1.tiltX,pointer2.tiltX,t)+90)*Math.PI/180)**2+Math.cos((lerp(pointer1.tiltY,pointer2.tiltY,t)+90)*Math.PI/180)**2);
                    width2 = width1*(1.5+projection_len*7);
                    ctx.beginPath();
                    ctx.ellipse(x,y,width2,width1,lerp(pointer1.twist,pointer2.twist,t)*Math.PI/180,0,Math.PI*2)
                    ctx.fill();
                }
                break;
        }
    }
}

document.querySelectorAll("#Eraser").forEach((x)=>{ // トグルボタン - 消しゴム選択
    x.dataset.stat = x.dataset.stat=="on"? "on": "off";
    x.addEventListener("click",(e)=>{
        e.target.dataset.stat = e.target.dataset.stat=="off"? "on": "off";
        document.querySelector("#PenType").dataset.eraser=e.target.dataset.stat;
    })
})
document.querySelectorAll("div.singleselectbtn").forEach((singleselect)=>{ // 一つだけ選べるボタン群 - ペン選択
    let buttons = [];
    for (let button of singleselect.querySelectorAll(":scope > button")) {
        buttons.push(button);
    }
    console.log(buttons)
    for (let button of buttons) {
        button.addEventListener("click",(e)=>{
            for (let button of buttons) {
                button.dataset.stat="off";
            }
            button.dataset.stat="on";
            singleselect.dataset.value=button.dataset.value;
            document.querySelector("#Eraser").dataset.stat="off"; // 消しゴムは無効化
            singleselect.dataset.eraser="off"
        })
        button.dataset.stat="off";
    }
    buttons[0].dataset.stat="on";
    singleselect.dataset.value=buttons[0].dataset.value;
})

function makebase() {
    const x = cnv.width;
    const y = cnv.height;
    noise = new Noise(Math.random());
    iarr = new Uint8ClampedArray(x * y * 4);
    let color = [250,248,245]
    for (iy = 0; iy < y; iy++) {
        for (ix = 0; ix < x; ix++) {
            c = noise.simplex2(ix*1,iy*1)*10+noise.simplex2(ix/10+10,iy/10+10)*3+noise.simplex2(iy/1000+15,ix/500+15)*10+245
            index = (iy*x+ix)*4; // index of position [ix,iy]
            iarr[index+0] = c*color[0]/255; // Red
            iarr[index+1] = c*color[1]/255; // Green
            iarr[index+2] = c*color[2]/255; // Blue
            iarr[index+3] = 255; // Alpha
        }
    }
    let basectx = basecnv.getContext("2d");
    basectx.putImageData(new ImageData(iarr,x,y),0,0)
}
</script>
<style>
    body {
        background-color: rgb(21, 10, 0);
        position: fixed;
        padding: 0;
        margin: 0;
    }
    canvas {
        cursor: crosshair;
        touch-action: none;
        position: absolute;
        left: 2px;
        top: 0;
        transform-origin: top left;
    }
    #mainarea {
        height: 100dvh;
        width: 100dvw;
    }
    #colorpicker {
        display: inline-block;
        width: 200px;
        height: 100%;
    }
    #linewidth {
        display: inline-block;
        width: 200px;
    }
    
    button {
        background-color: rgb(240, 238, 238);
        border: 1px solid white;
        border-radius: 4px;
        &:hover {
            background-color: rgb(228, 218, 218);
        }
        &:active {
            background-color: rgb(202, 196, 196);
        }
    }

    .toggle[data-stat="off"], .singleselectbtn > [data-stat="off"], .singleselectbtn[data-eraser="on"] > button {
        background-color: rgb(124, 115, 115);
        &:hover {
            background-color: rgb(133, 124, 124);
        }
    }
    .singleselectbtn[data-eraser="on"] > button[data-stat="on"] {
        background-color: rgb(172, 151, 151);
        &:hover {
            background-color: rgb(181, 172, 172);
        }
    }
</style>
<style>

/* resizer */
.resizer_Vcontainer {
    display: flex;
    flex-direction: column;
    height: 100%;
    & > .resizer_content {
        min-height: 0px;
        height: 100%;
        overflow: hidden;
        padding: 3px;
    }
    & > .resizer_splitter {
        height: 2px;
        margin: 2px;
        width: calc(100% - 10px);
        border-radius: 3px;
        flex: none;
        cursor: row-resize;
        background-color: #7c7c7c;
    }
    & > .resizer_splitter:hover {
        background-color: #acacac;
    }
}
.resizer_Hcontainer {
    display: flex;
    flex-direction: row;
    height: 100%;
    & > .resizer_content {
        min-width: 0px;
        width: 100%;
        overflow: hidden;
        padding: 3px;
    }
    & > .resizer_splitter {
        width: 2px;
        margin: 2px;
        height: calc(100% - 10px);
        border-radius: 3px;
        flex: none;
        cursor: col-resize;
        background-color: #7c7c7c;
    }
    & > .resizer_splitter:hover {
        background-color: #acacac;
    }
}
</style>