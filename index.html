<!DOCTYPE html>
<html>
    <head>
        <title>Neknaj Paint</title>
        <meta charset="utf*8">
        <meta property="og:title" content="Neknaj Paint">
        <meta property="og:description" content="Paint software that runs on a web browser">
        <meta property="description" content="Paint software that runs on a web browser">
    </head>
    <body>
        <div class="resizer_Hcontainer" id="mainarea" data-proportion="15:1">
            <div class="resizer_content">
                <div class="resizer_Vcontainer" data-proportion="13:1">
                    <div class="resizer_content" id="imgOutArea"><canvas id="canvas"></canvas></div>
                    <div class="resizer_splitter"></div>
                    <div class="resizer_content">
                        <input type="color" id="colorpicker">
                        <input type="range" id="linewidth" min="-15" max="15">
                    </div>
                </div>
            </div>
            <div class="resizer_splitter"></div>
            <div class="resizer_content"></div>
        </div>
    </body>
</html>
<script>
function resizer_Vcontainer_addEL (container,framesMin,callback=()=>{}) {
    container.querySelector(":scope > .resizer_splitter").addEventListener("pointerdown",(e)=>{
        let resizer = container.querySelector(":scope > .resizer_splitter").getBoundingClientRect();
        let resizerW = resizer.bottom - resizer.top;
        let resize = (e)=>{
            let containerRect = container.getBoundingClientRect();
            let y = ((n,min,max)=>{if (n<min) {n=min}else if (n>max) {n=max};return n;})(e.y-containerRect.y,framesMin,containerRect.height-resizerW-framesMin);
            container.querySelectorAll(":scope > .resizer_content")[0].style.flexBasis = `${y}%`;
            container.querySelectorAll(":scope > .resizer_content")[1].style.flexBasis = `${containerRect.height-resizerW-y}%`;
            callback();
        }
        document.addEventListener("pointermove",resize,false);
        document.addEventListener("pointerup",()=>{document.removeEventListener("pointermove",resize,false);},false);
        e.target.setPointerCapture(e.pointerId);
    });
    let p = container.dataset["proportion"].split(":").map((x)=>{return Number(x);});
    container.querySelectorAll(":scope > .resizer_content")[0].style.flexBasis = `${(p[0]*100/(p[0]+p[1]))}%`;
    container.querySelectorAll(":scope > .resizer_content")[1].style.flexBasis = `${(p[1]*100/(p[0]+p[1]))}%`;
}
function resizer_Hcontainer_addEL (container,framesMin,callback=()=>{}) {
    container.querySelector(":scope > .resizer_splitter").addEventListener("pointerdown",(e)=>{
        let resizer = container.querySelector(":scope > .resizer_splitter").getBoundingClientRect();
        let resizerW = resizer.right - resizer.left;
        let resize = (e)=>{
            let containerRect = container.getBoundingClientRect();
            let x = ((n,min,max)=>{if (n<min) {n=min}else if (n>max) {n=max};return n;})(e.x-containerRect.x,framesMin,containerRect.width-resizerW-framesMin);
            container.querySelectorAll(":scope > .resizer_content")[0].style.flexBasis = `${x}%`;
            container.querySelectorAll(":scope > .resizer_content")[1].style.flexBasis = `${containerRect.width-resizerW-x}%`;
            callback();
        }
        document.addEventListener("pointermove",resize,false);
        document.addEventListener("pointerup",()=>{document.removeEventListener("pointermove",resize,false);},false);
        e.target.setPointerCapture(e.pointerId);
    });
    let p = container.dataset["proportion"].split(":").map((x)=>{return Number(x);});
    container.querySelectorAll(":scope > .resizer_content")[0].style.flexBasis = `${(p[0]*100/(p[0]+p[1]))}%`;
    container.querySelectorAll(":scope > .resizer_content")[1].style.flexBasis = `${(p[1]*100/(p[0]+p[1]))}%`;
}
document.querySelectorAll(".resizer_Vcontainer").forEach((x)=>{resizer_Vcontainer_addEL(x,50,resize);})
document.querySelectorAll(".resizer_Hcontainer").forEach((x)=>{resizer_Hcontainer_addEL(x,50,resize);})
function resize() {
    {
        const dw = imageConfig.width;
        const dh = imageConfig.height;
        let rw = 0;let rh = 0;
        parent = imgOutArea.getBoundingClientRect();
        let ww = parent.width;
        let wh = parent.height;
        let csc = 1
        hcsc = ww/dw; wcsc = wh/dh;
        if (hcsc>wcsc) {
            csc = wcsc; rw = (ww - dw*csc)/2;
        }
        else {
            csc = hcsc; rh = (wh - dh*csc)/2;
        }
        cnv.style.marginTop = (rh).toString()+"px";
        cnv.style.marginBottom = (rh).toString()+"px";
        cnv.style.marginLeft = (rw).toString()+"px";
        cnv.style.marginRight = (rw).toString()+"px";
        cnv.style.transform = "scale("+csc.toString()+","+csc.toString()+")";
    }
};
window.onresize = resize;
window.onload = ()=>{
    cnv.height = 1080;
    cnv.width = 1920;
    resize();
};
</script>
<script>
</script>
<script>
var imageConfig = {
    width: 1920,
    height: 1080
}
var cnv = document.getElementById("canvas");
let ctx = cnv.getContext("2d");
let imgOutArea = document.getElementById("imgOutArea");
// resize window

cnv.addEventListener("contextmenu", (e)=>{e.preventDefault();}, false);

cnv.addEventListener("pointermove", draw, false);

cnv.addEventListener("pointerup", endpath, false);
cnv.addEventListener("pointercancle", endpath, false);
cnv.addEventListener("pointerout", endpath, false);
cnv.addEventListener("pointerleave", endpath, false);

document.addEventListener("keydown",(e)=>{
    console.log("keydown",e.keyCode)
    if (e.keyCode == 90 && e.ctrlKey) {
        cnv_history_trash.push(cnv_history.pop());
        ctx.putImageData(cnv_history[cnv_history.length-1],0,0);
    }
    if (e.keyCode == 89 && e.ctrlKey) {
        if (cnv_history_trash.length>0) {
            cnv_history.push(cnv_history_trash.pop());
            ctx.putImageData(cnv_history[cnv_history.length-1],0,0);
        }
    }
},false);

function logEvents(e) {
    console.log(e);
    return;
}

var stroke = [];
var cnv_history = [];
var cnv_history_trash = [];
let image = ctx.getImageData(0,0,1920,1080);
cnv_history.push(image);

function draw(e) {
   // console.log(e.getCoalescedEvents())
    var rect = cnv.getBoundingClientRect();
    let ns = {x:(e.clientX-rect.left)/(rect.right-rect.left)*cnv.width,y:(e.clientY-rect.top)/(rect.bottom-rect.top)*cnv.height,time:performance.now()}
    let bs = stroke[stroke.length-1]??ns;
    let speed = Math.sqrt((bs.x-ns.x)**2+(bs.y-ns.y)**2)/(ns.time-bs.time);
    let drawfunc = (e)=>{
       // console.log(e)
        let pointer = {
            x: (e.clientX-rect.left)/(rect.right-rect.left)*cnv.width,
            y: (e.clientY-rect.top)/(rect.bottom-rect.top)*cnv.height,
            time: performance.now(),
            tiltX: e.pointerType=="pen"?e.tiltX:0,
            tiltY: 0,
            twist: e.pointerType=="pen"?e.tiltY:0,
            pressure: e.pointerType=="pen"?e.pressure:0.5,
            pointerType: e.pointerType,
            speed: speed,
        }
        console.log(pointer)
        switch (e.buttons) {
            case 1:
                drawpath(pointer);
                //logEvents(pointer);
            break;
        }
    }
    if (e.getCoalescedEvents) {
        for (e of e.getCoalescedEvents()) {
            drawfunc(e);
        }
    }
    else {
        drawfunc(e);
    }
}

function drawpath(e) {
    {
        stroke.push(e);
        // ctx.beginPath();
        // ctx.arc(e.x,e.y,10,0,Math.PI*2)
        // ctx.stroke();
       // console.log(e)
    }

    let linewidth = 10*1.1**Number(document.querySelector("#linewidth").value);
    console.log(linewidth);
    let color = document.querySelector("#colorpicker").value.slice(1).match(/.{2}/g).map((x)=>{return parseInt(x,16)});
    ctx.fillStyle = `rgb(${color.join(",")},0.05)`;
    ctx.lineCap = "round";
    if (stroke.length>3) {
        i = stroke.length-1;
        let p0 = stroke[i-2];
        let p1 = stroke[i-1];
        let p2 = stroke[i];
        let m1 = midpoint(p0,p1);
        let m2 = midpoint(p1,p2);
        drawQuadraticCurve(m1,p1,m2,p0,p1,linewidth);
    }
}
function endpath(e) {
    if (stroke.length>2) {
        let image = ctx.getImageData(0,0,1920,1080);
        cnv_history.push(image);
        cnv_history_trash = [];
        console.log(cnv_history);
    }
    stroke = [];
}

function midpoint(p1,p2) {
    return {x:(p1.x+p2.x)/2,y:(p1.y+p2.y)/2}
}
function lerp(a,b,t) {
    return a + t*(b-a)
}

function drawQuadraticCurve(p0,p1,p2,pointer1,pointer2,linewidth) {
    for (let t=0;t<=1;t+=0.005) {
        x = (p0.x-2*p1.x+p2.x)*t*t+(-2*p0.x+2*p1.x)*t+p0.x;
        y = (p0.y-2*p1.y+p2.y)*t*t+(-2*p0.y+2*p1.y)*t+p0.y;
        {
            width1 = linewidth*lerp(pointer1.pressure,pointer2.pressure,t)**1.2*2;
            let projection_len = Math.sqrt(Math.cos((lerp(pointer1.tiltX,pointer2.tiltX,t)+90)*Math.PI/180)**2+Math.cos((lerp(pointer1.tiltY,pointer2.tiltY,t)+90)*Math.PI/180)**2);
            width2 = width1*(1+projection_len*7);
        }
        ctx.beginPath();
        ctx.ellipse(x,y,width2,width1,lerp(pointer1.twist,pointer2.twist,t)*Math.PI/180,0,Math.PI*2)
        ctx.fill();
    }
}

</script>
<style>
    body {
        background-color: rgb(0, 0, 21);
        position: fixed;
        padding: 0;
        margin: 0;
    }
    canvas {
        background-color: rgb(255, 255, 255);
        cursor: crosshair;
        touch-action: none;
        position: absolute;
        left: 2px;
        top: 0;
        transform-origin: top left;
    }
    #mainarea {
        height: 100dvh;
        width: 100dvw;
    }
    #colorpicker {
        display: inline-block;
        width: 200px;
        height: 100%;
    }
    #linewidth {
        display: inline-block;
        width: 200px;
    }
</style>
<style>

/* resizer */
.resizer_Vcontainer {
    display: flex;
    flex-direction: column;
    height: 100%;
    & > .resizer_content {
        min-height: 0px;
        height: 100%;
        overflow: hidden;
        padding: 3px;
    }
    & > .resizer_splitter {
        height: 2px;
        margin: 2px;
        width: calc(100% - 10px);
        border-radius: 3px;
        flex: none;
        cursor: row-resize;
        background-color: #7c7c7c;
    }
    & > .resizer_splitter:hover {
        background-color: #acacac;
    }
}
.resizer_Hcontainer {
    display: flex;
    flex-direction: row;
    height: 100%;
    & > .resizer_content {
        min-width: 0px;
        width: 100%;
        overflow: hidden;
        padding: 3px;
    }
    & > .resizer_splitter {
        width: 2px;
        margin: 2px;
        height: calc(100% - 10px);
        border-radius: 3px;
        flex: none;
        cursor: col-resize;
        background-color: #7c7c7c;
    }
    & > .resizer_splitter:hover {
        background-color: #acacac;
    }
}
</style>